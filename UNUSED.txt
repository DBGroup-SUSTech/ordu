vector<float> computePairHP(const int dimen, float* PG[], long int pi, long int pj)
{
	vector<float> retHS;
	float piv[MAXDIMEN];
	float pjv[MAXDIMEN];
	for (int d = 0; d < dimen; d++)
	{
		piv[d] = (PG[pi][d] + PG[pi][dimen + d]) / 2.0;
		pjv[d] = (PG[pj][d] + PG[pj][dimen + d]) / 2.0;
	}

	float pj_d = pjv[dimen - 1];
	float pi_d = piv[dimen - 1];
	for (int d = 0; d < dimen - 1; d++)
	{
		retHS.push_back((pjv[d] - pj_d) - (piv[d] - pi_d));
	}
	retHS.push_back(pi_d - pj_d);
	return retHS;
}

vector<long int> computeTopK(const int dim, float* PG[], vector<long int> skyband, vector<float>& weight, int k)
{
	multimap<float, long int> heap;

	for (int i = 0; i < skyband.size(); i++)
	{
		float score = 0;
		float l1_sumWeight = 0;
		for (int d = 0; d < dim-1; d++)
		{
			score += (PG[skyband[i]][d] + PG[skyband[i]][d + dim]) / 2*weight[d];
            l1_sumWeight += weight[d];
		}
        score += (PG[skyband[i]][dim - 1] + PG[skyband[i]][dim - 1 + dim]) / 2 * (1 - l1_sumWeight);

		if (heap.size() < k)
		{
			heap.insert(multimap<float, long int>::value_type(score, skyband[i]));
			//could use emplace， e.g. “heap.emplace(score, skyband[i])”
		}
		else if (heap.size() == k && heap.begin()->first < score)
		{
			heap.erase(heap.begin());
			heap.emplace(score, skyband[i]);
		}
	}

	vector<long int> topkRet;
	for (auto heapIter = heap.rbegin(); heapIter != heap.rend(); ++heapIter)
	{
		topkRet.push_back(heapIter->second);
	}
	return topkRet;
}

bool incomparableset(float* PG[], long int pi, long int pj, vector<float>& weight)
{
	int dimen = weight.size() + 1;
	float l1_wd = 0;
	float spi = 0, spj = 0;
	int cpos = 0;
	int cneg = 0;

	float piv[MAXDIMEN];
	float pjv[MAXDIMEN];
	for (int d = 0; d < dimen; d++)
	{
		piv[d] = (PG[pi][d] + PG[pi][dimen + d]) / 2.0;
		pjv[d] = (PG[pj][d] + PG[pj][dimen + d]) / 2.0;
	}

	for (int i = 0; i < dimen - 1; i++)
	{
		spi += piv[i] * weight[i];
		spj += pjv[i] * weight[i];
        l1_wd += weight[i];

		if (piv[i] <= pjv[i])
		{
			cneg++;
		}
		else
		{
			cpos++;
		}
	}

	spi += (1 - l1_wd) * piv[dimen - 1];
	spj += (1 - l1_wd) * pjv[dimen - 1];

	if (piv[dimen - 1] <= pjv[dimen - 1])
	{
		cneg++;
	}
	else
	{
		cpos++;
	}

	if (spj >= spi && cneg != 0 && cpos != 0)
		return true;
	else
		return false;
}